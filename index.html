<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Tempo Shape â€” Block Layout (Top/Middle/Bottom)</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    :root{ --text:#e5e7eb; --muted:#94a3b8; --bg:#000; }
    *{ box-sizing:border-box; font-family: Helvetica, Arial, sans-serif; }

    html,body{ height:100%; margin:0; }
    body{
      min-height:100svh; /* stable viewport on mobile */
      display:flex; flex-direction:column;
      background:#000; color:var(--text);
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      overflow:hidden; /* prevent accidental scroll */
    }

    /* Top controls (fixed height, sits at top) */
    .controls{ flex:0 0 auto; display:flex; gap:16px; justify-content:center; align-items:flex-start; padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.08); background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); overflow-x:auto; }
    .input-group{ display:flex; flex-direction:column; align-items:center; }
    .input-group input{ width:44px; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.05); color:var(--text); font-size:16px; text-align:center; }
    .input-group span{ font-size:12px; color:var(--muted); margin-top:4px; text-align:center; }

    /* Middle stage (always between top & bottom bars) */
    .stage-wrap{ position:relative; flex:1 1 auto; min-height:220px; }
    #stage{ width:100%; height:100%; display:block; }
    #cycleCounter{ position:absolute; left:50%; transform:translateX(-50%); bottom:10px; font-size:28px; font-weight:700; color:#eef6ff; pointer-events:none; }

    /* Bottom buttons (fixed height, sits at bottom, not overlay) */
    .buttons{ flex:0 0 auto; display:flex; gap:16px; justify-content:center; align-items:flex-end; padding:14px calc(14px + env(safe-area-inset-bottom)); border-top:1px solid rgba(255,255,255,.08); background:linear-gradient(0deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); }
    .round{ width:64px; height:64px; border-radius:50%; border:1px solid rgba(255,255,255,.14); display:flex; align-items:center; justify-content:center; color:#fff; cursor:pointer; }
    .round.primary{ background:#1e3a8a; } /* dark blue */
    .round.danger{ background:#7f1d1d; } /* dark red */
    .round svg{ width:28px; height:28px; fill:currentColor; }

    /* Pill dropdown (Countdown) */
    .bottom-group{ display:flex; flex-direction:column; align-items:center; gap:4px; }
    .bottom-label{ font-size:12px; color:var(--muted); }
    .pill-select{ position:relative; }
    .pill-select select{
      -webkit-appearance:none; appearance:none; outline:none;
      border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06);
      color:var(--text); padding:10px 36px 10px 14px; border-radius:9999px; font-size:16px; text-align-last:center; cursor:pointer;
    }
    .pill-select svg{ position:absolute; right:10px; top:50%; transform:translateY(-50%); pointer-events:none; width:16px; height:16px; opacity:.9; }

    .status{ position:fixed; right:12px; bottom:calc(88px + env(safe-area-inset-bottom)); color:var(--muted); font-size:12px; background:rgba(0,0,0,.28); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.08); }
  </style>
</head>
<body>
  <!-- Top: Inputs -->
  <div class="controls">
    <div class="input-group"><input id="lower" type="number" step="0.1" min="0" value="4"><span>Lower</span></div>
    <div class="input-group"><input id="pause1" type="number" step="0.1" min="0" value="2"><span>Pause</span></div>
    <div class="input-group"><input id="lift" type="number" step="0.1" min="0" value="4"><span>Lift</span></div>
    <div class="input-group"><input id="pause2" type="number" step="0.1" min="0" value="2"><span>Pause again</span></div>
  </div>

  <!-- Middle: Canvas -->
  <div class="stage-wrap" id="stageWrap">
    <canvas id="stage"></canvas>
    <div id="cycleCounter">0</div>
  </div>

  <!-- Bottom: Buttons + Countdown (pill) -->
  <div class="buttons">
    <button id="playPause" class="round primary" aria-label="Start">
      <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
    </button>
    <button id="stop" class="round danger" aria-label="Stop">
      <svg viewBox="0 0 24 24"><path d="M6 6h12v12H6z"/></svg>
    </button>
    <div class="bottom-group">
      <span class="bottom-label">Countdown</span>
      <div class="pill-select">
        <select id="precount" aria-label="Countdown">
          <option value="0">None</option>
          <option value="3">3s</option>
          <option value="5" selected>5s</option>
          <option value="10">10s</option>
        </select>
        <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M7 10l5 5 5-5z"/></svg>
      </div>
    </div>
  </div>

  <div class="status" id="status">Idle.</div>

  <script>
    // Elements
    const canvas = document.getElementById('stage');
    const stageWrap = document.getElementById('stageWrap');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const cycleCounterEl = document.getElementById('cycleCounter');

    const inputLower=document.getElementById('lower');
    const inputPause1=document.getElementById('pause1');
    const inputLift=document.getElementById('lift');
    const inputPause2=document.getElementById('pause2');
    const selectPrecount=document.getElementById('precount');

    const btnPlayPause=document.getElementById('playPause');
    const btnStop=document.getElementById('stop');

    // Viewport
    let viewW=1, viewH=1, dpr=1;

    // State
    const STATE = { PRECOUNT:'precount', EXPAND:'expand', PAUSE1:'pause1', CONTRACT:'contract', PAUSE2:'pause2' };
    let durations = { lower:4000, pause1:2000, lift:4000, pause2:2000 };
    let minScale=0.45, maxScale=1.0, scale=minScale;
    let state=STATE.PAUSE2, stateStart=performance.now();
    let preCountEnd = 0;
    let running=false, paused=false, pausedAt=0;
    let dashOffset=0, lastTickTs=performance.now();
    let cycles=0;

    // Utils
    function clamp01(t){ return Math.max(0,Math.min(1,t)); }
    function easeInOutCubic(t){ t=clamp01(t); return t<0.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2; }
    function tintForState(s){
      if(s===STATE.EXPAND) return [59,130,246];
      if(s===STATE.CONTRACT) return [52,211,153];
      if(s===STATE.PAUSE1||s===STATE.PAUSE2) return [239,68,68];
      return [200,200,200];
    }
    function parseDurations(){
      const val=(el)=>{const n=parseFloat(el.value);return Number.isFinite(n)&&n>=0?n:0;};
      durations={lower:val(inputLower)*1000,pause1:val(inputPause1)*1000,lift:val(inputLift)*1000,pause2:val(inputPause2)*1000};
    }

    // Pure measure-based resize (middle never overlaps bars)
    function resize(){
      dpr=Math.min(window.devicePixelRatio||1,2);
      const rect = stageWrap.getBoundingClientRect();
      viewW = Math.floor(rect.width);
      viewH = Math.floor(rect.height);
      canvas.width=Math.floor(viewW*dpr); canvas.height=Math.floor(viewH*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', ()=>{ resize(); draw(performance.now()); }, {passive:true});
    if(window.visualViewport){
      window.visualViewport.addEventListener('resize', ()=>{ resize(); draw(performance.now()); }, {passive:true});
      window.visualViewport.addEventListener('scroll', ()=>{ resize(); draw(performance.now()); }, {passive:true});
    }

    // Loop
    function loop(ts){
      if(!running) return;
      const now=paused?pausedAt:(typeof ts==='number'?ts:performance.now());
      const dt=(now-lastTickTs)/1000;
      if(state===STATE.EXPAND) dashOffset+=80*dt; else if(state===STATE.CONTRACT) dashOffset-=80*dt;
      lastTickTs=now;
      updateState(now); draw(now);
      requestAnimationFrame(loop);
    }

    function updateState(now){
      const elapsed=now-stateStart;
      if(state===STATE.PRECOUNT){ if(now>=preCountEnd){ state=STATE.EXPAND; stateStart=now; } return; }
      if(state===STATE.EXPAND){
        const dur=durations.lower; const t=clamp01(elapsed/dur);
        scale=minScale+(maxScale-minScale)*easeInOutCubic(t);
        if(elapsed>=dur){state=STATE.PAUSE1;stateStart=now;scale=maxScale;}
      } else if(state===STATE.PAUSE1){
        if(elapsed>=durations.pause1){state=STATE.CONTRACT;stateStart=now;}
      } else if(state===STATE.CONTRACT){
        const dur=durations.lift; const t=clamp01(elapsed/dur);
        scale=maxScale-(maxScale-minScale)*easeInOutCubic(t);
        if(elapsed>=dur){state=STATE.PAUSE2;stateStart=now;scale=minScale;}
      } else if(state===STATE.PAUSE2){
        if(elapsed>=durations.pause2){cycles+=1;cycleCounterEl.textContent=cycles;state=STATE.EXPAND;stateStart=now;}
      }
    }

    function draw(now){
      ctx.clearRect(0,0,viewW,viewH);
      ctx.save(); ctx.translate(viewW/2,viewH/2);

      if(state===STATE.PRECOUNT){
        const remainingMs = Math.max(0, preCountEnd - now);
        const remainingSec = Math.ceil(remainingMs/1000);
        ctx.fillStyle = '#eef6ff'; ctx.textAlign='center'; ctx.textBaseline='middle';
        const fontSize = Math.max(28, Math.min(viewW,viewH)*0.24);
        ctx.font = `700 ${fontSize}px Helvetica, Arial, sans-serif`;
        ctx.fillText(Number.isFinite(remainingSec)?remainingSec:'', 0, 0);
        ctx.restore(); return;
      }

      // Compute radius that always fits middle zone and leaves room for counter label beneath
      const margin = 12;      // interior breathing room
      const counterH = 40;    // reserve space for counter inside middle zone
      const maxRByH = Math.max(36, (viewH - counterH - margin*2)/2);
      const maxRByW = Math.max(36, (viewW - margin*2)/2);
      const outlineR = Math.min(maxRByH, maxRByW);

      // Counter is anchored via CSS (bottom:10px) inside the middle zone; no JS positioning needed.

      const radius=outlineR*scale;
      ctx.save(); ctx.setLineDash([12,10]); ctx.lineDashOffset=dashOffset; ctx.lineWidth=1.5; ctx.strokeStyle='rgba(255,255,255,0.55)';
      ctx.beginPath(); ctx.arc(0,0,outlineR,0,Math.PI*2); ctx.stroke(); ctx.restore();

      // Tint logic (pauses darken per second)
      let tint;
      if (state===STATE.PAUSE1 || state===STATE.PAUSE2) {
        const pauseDur = state===STATE.PAUSE1 ? durations.pause1 : durations.pause2;
        const steps = Math.max(1, Math.floor(pauseDur/1000));
        const elapsedPause = Math.max(0, now - stateStart);
        const step = Math.min(steps, Math.floor(elapsedPause/1000));
        const bright = [239, 68, 68];
        const dark   = [160, 20, 20];
        const t = steps > 0 ? step/steps : 1;
        tint = [
          Math.round(bright[0] + (dark[0]-bright[0]) * t),
          Math.round(bright[1] + (dark[1]-bright[1]) * t),
          Math.round(bright[2] + (dark[2]-bright[2]) * t)
        ];
      } else if (state===STATE.EXPAND) {
        tint = [59,130,246];
      } else if (state===STATE.CONTRACT) {
        tint = [52,211,153];
      } else {
        tint = [200,200,200];
      }

      ctx.fillStyle=`rgb(${tint[0]},${tint[1]},${tint[2]})`;
      ctx.beginPath(); ctx.arc(0,0, radius, 0, Math.PI*2); ctx.fill();

      let dur=0; if(state===STATE.EXPAND) dur=durations.lower; else if(state===STATE.PAUSE1) dur=durations.pause1; else if(state===STATE.CONTRACT) dur=durations.lift; else dur=durations.pause2;
      const remMs=Math.max(0, dur - (now - stateStart)); const remSec=Math.ceil(remMs/1000);
      ctx.fillStyle='#eef6ff'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font=`700 ${Math.max(16, radius*0.32)}px Helvetica, Arial, sans-serif`;
      ctx.fillText(Number.isFinite(remSec)?remSec:'', 0, 0);

      ctx.restore();
    }

    // Controls
    function start(){
      parseDurations(); cycles=0; cycleCounterEl.textContent='0';
      running=true; paused=false;
      const pre = parseInt(selectPrecount.value, 10) || 0;
      stateStart = performance.now(); lastTickTs=stateStart;
      if(pre>0){ state=STATE.PRECOUNT; preCountEnd = stateStart + pre*1000; }
      else { state=STATE.EXPAND; }
      statusEl.textContent='Running';
      updatePlayPauseIcon();
      requestAnimationFrame(loop);
    }
    function stop(){
      running=false; paused=false;
      scale=minScale; state=STATE.PAUSE2; stateStart=performance.now(); dashOffset=0; cycles=0; cycleCounterEl.textContent='0';
      statusEl.textContent='Stopped';
      updatePlayPauseIcon();
      draw(performance.now());
    }
    function togglePlayPause(){
      if(!running){ start(); return; }
      if(!paused){ paused=true; pausedAt=performance.now(); statusEl.textContent='Paused.'; }
      else { paused=false; const delta=performance.now()-pausedAt; stateStart+=delta; if(state===STATE.PRECOUNT) preCountEnd+=delta; lastTickTs+=delta; statusEl.textContent='Runningâ€¦'; }
      updatePlayPauseIcon();
    }

    btnPlayPause.addEventListener('click', togglePlayPause);
    btnStop.addEventListener('click', stop);

    function updatePlayPauseIcon(){
      const isPauseIcon = running && !paused;
      btnPlayPause.setAttribute('aria-label', isPauseIcon ? 'Pause' : 'Start');
      btnPlayPause.innerHTML = isPauseIcon
        ? '<svg viewBox="0 0 24 24"><path d="M6 5h4v14H6zM14 5h4v14h-4z"/></svg>'
        : '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
    }

    // Init
    resize(); draw(performance.now());
    updatePlayPauseIcon();
  </script>
</body>
</html>

